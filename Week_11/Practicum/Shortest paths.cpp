#include <bits/stdc++.h>
using namespace std;

const int MOD = 1e9 + 7;

int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    
    int N, M; // N: брой върхове, M: брой ребра
    cin >> N >> M;
    
    // Създаваме списък на съседите за представяне на графа
    // graph[u] ще съдържа всички ребра, изходящи от върха u
    // Всяко ребро се представя като двойка (v, w), където:
    // v: върхът, към който е насочено реброто
    // w: теглото на реброто
    vector<vector<pair<int, int>>> graph(N+1, vector<pair<int, int>>());
    
    // Четем M ребра и ги добавяме към съседния списък
    for(int i = 0; i < M; i++){
        int u, v, w; // u: началния връх, v: крайния връх, w: тегло на реброто
        cin >> u >> v >> w;
        graph[u].push_back({v, w}); // Добавяме реброто към списъка на върха u
    }
    
    int A = 1; // Началният връх 
    int B = N; // Крайният връх 
    
    // Инициализираме масивите за разстояния и броя пътища
    // dist[i]: минималното разстояние от A до i
    // ways[i]: броя начини да се достигне връх i с минимално разстояние
    vector<long long> dist(N+1, LLONG_MAX); 
    vector<long long> ways(N+1, 0); 

    dist[A] = 0; // Разстоянието до началния връх е 0
    ways[A] = 1; // Има точно 1 начин да се остане на началния връх
    
    // Дефинираме приоритетна опашка (min-heap) за Дийкстра
    // Всяка двойка съдържа (разстояние до върха, върх)
    priority_queue<pair<long long, int>, vector<pair<long long, int>>, std::greater<pair<long long, int>>> pq;
    pq.push({0, A}); // Добавяме началния връх към опашката
    
    // Изпълняваме алгоритъма на Дийкстра
    while(!pq.empty()){
        // Изваждаме върха с най-малко текущо разстояние
        auto [current_dist, u] = pq.top();
        pq.pop();
        
        // Ако вече сме намерили по-добър път до върха u
        if(current_dist > dist[u]) 
            continue;
        
        // Разглеждаме всички съседни върхове на u
        for(auto &[v, w] : graph[u]){
            // Ако намерим по-добър път до върха v чрез u
            if(dist[v] > dist[u] + w){
                dist[v] = dist[u] + w; 
                ways[v] = ways[u]; // Броят на пътищата до v е равен на броя на пътищата до u
                pq.push({dist[v], v}); // Добавяме върха v към опашката за обработка
            }
            // Ако намерим друг път до върха v със същото минимално разстояние
            else if(dist[v] == dist[u] + w){
                ways[v] = (ways[v] + ways[u]) % MOD; // Увеличаваме броя на пътищата до v
            }
        }
    }
    
    // Проверяваме дали има път от A до B
    if(dist[B] == LLONG_MAX){
        cout << "-1 0";
    }
    else{
        // Ако има път, изписваме минималното разстояние и броя на пътищата
        cout << dist[B] << " " << ways[B];
    }
    
    return 0;
}
