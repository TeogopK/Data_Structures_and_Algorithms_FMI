/*
    Даден ни е вектор от цели числа nums и търсим дължината на най-дългия подмасив, започващ от индекс 0,
    за който е вярно, че ако премахнем точно 1 елемент, всички останали ще се срещат с еднаква честота (равен брой пъти).
    
    За фиксиран индекс i подмасивът nums[0..i] има i + 1 на брой елементи и ще отговаря на условието, ако е вярно едно от трите:
        1) всички елементи се срещат точно по веднъж
        2) има точно 1 елемент, който се среща веднъж, а всички останали се срещат равен брой пъти t
        3) има точно 1 елемент, който се среща t пъти, а всички останали се срещат равен брой пъти t - 1

    Сега въпросът е как лесно да проверим горните условия. Ще ни трябва променлива maxFreq (ред 27), която следи за максималната честота в nums[0..i]
    С нея лесно проверяваме условие 1), а в условия 2) и 3) maxFreq e t. За да проверим първата част от условие 2) и 3),
    ни трябва да знаем за някоя честота t колко са числата с нея. Удобно е да използваме unordered_map<int, int> freqCount (ред 28) и за да може лесно да го ъпдейтваме,
    ще използваме unoredered_map<int, in> numFreq (ред 29), който за всяко число пази честотата на срещанията му в nums[0..i]. 
    За да проверим втората част на условия 2) и 3), се досещаме, че ако съберем честотите на всички числа в подмасива, ще получим общия брой числа (i + 1).
    Тогава, за да проверим дали всички числа без едно се срещат t или t - 1 пъти, 
    умножаваме броя на числата с честота t или t - 1 по честотата, добавяме честотата на едното число и сравняваме с общия брoй числа. Така условията са:
        1) maxFreq == 1 (ред 41)
        2) freqCount[1] == 1 && freqCount[maxFreq] * maxFreq + 1 == i + 1 (ред 42)
        3) freqCount[maxFreq] == 1 && freqCount[maxFreq - 1] * (maxFreq - 1) + maxFreq == i + 1 (ред 44)
    
    Нататък задачата е ясна - актуализираме numFreq, freqCount, maxFreq в началото на всяка стъпка на for-цикъла (ред 33-38) и след това проверяваме условията.
*/

class Solution {
public:
    int maxEqualFreq(vector<int>& nums) {
        int maxFreq = 0;
        std::unordered_map<int, int> freqCount;
        std::unordered_map<int, int> numFreq;
        int maxLen = 0;

        for (int i = 0; i < nums.size(); ++i) {
            int &freq = numFreq[nums[i]];
            if (freqCount.count(freq)) {
                freqCount[freq]--;
            }
            freqCount[++freq]++;
            maxFreq = std::max(maxFreq, freq);

            if (
                maxFreq == 1 ||
                (freqCount[1] == 1 && maxFreq * freqCount[maxFreq] == i) ||
                (freqCount[maxFreq] == 1 && (maxFreq - 1) * (freqCount[maxFreq - 1] + 1) == i)
            ) {
                maxLen = i + 1;
            }
        }

        return maxLen;
    }
};
