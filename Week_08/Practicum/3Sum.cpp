/*
    Даден ни е вектор oт цели числа nums и търсим всички тройки числа със сума 0, като връщаме само уникалните тройки.

    Трябват ни 3 индекса i < j < k, т.ч. nums[i] + nums[j] + nums[k] = 0. Ясно е, че ако фиксираме i, 
    лесно свеждаме проблема до 2Sum: търсим индекси j < k, т.ч. nums[j] + nums[k] = -nums[i], което вече можем да решим.
    
    По-трудното в задачата е да върнем само уникалните тройки числа.
    Един вариант е намерените тройки да ги сортираме по компоненти и да ги пазим в std::set<std::tuple<int, int, int>>, 
    след което да създадем std::vector<std::vector<int>> oт сета. Може елементите на сета да бъдат вектори, 
    но тогава ще трябва да подадем функция, по която да се сравняват два вектора. Ако искаме да ползваме unordered_set, ще се наложи
    да имплементираме някаква хеш функция за tuple или vector, защото няма предефинирани такива. Всички тези решения са валидни, но тромави.

    Най-лесното решение е да сортираме дадения вектор още в началото (ред 27) и когато добавяме <число, индекс> в unordered_map<int, int>,
    който ползваме за 2Sum, всъщност за всяка стойност ще имаме последния индекс, на който се среща (ред 30). 
    Когато сведем проблема до 2Sum за индекса j (ред 36), независимо дали има решение, или не, 
    ще преместим j да сочи към последния индекс, на който се намира nums[j] (ред 40), като по този начин пропускаме повтарящите се решения.
    Аналогично постъваме и с индекса i (ред 42).

*/
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        if (nums.size() < 3) {
            return {};
        }
        
        std::sort(nums.begin(), nums.end());
        std::unordered_map<int, int> rev;
        for (int i = 0; i < nums.size(); ++i) {
            rev[nums[i]] = i;
        }

        std::vector<std::vector<int>> triplets;
        for (int i = 0; i < nums.size(); ++i) {
            int target = -nums[i];
            for (int j = i + 1; j < nums.size(); ++j) {
                if (rev.count(target - nums[j]) && rev[target - nums[j]] > j) {
                    triplets.push_back({nums[i], nums[j], target - nums[j]});
                }
                j = rev[nums[j]];
            }
            i = rev[nums[i]];
        }

        return triplets;
    }
};
