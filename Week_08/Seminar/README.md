
# Упражнение 8

# Балансирани дървета, Хештаблици

## Балансирани дървета

### AVL tree (АВЛ дърво)

- Самобалансиращо се двоично дърво за търсене.
- Разликата във височината на лявото и дясното поддърво за всеки възел е по-малка или равна 1.
- Гарантирана *O(logN)* сложност в най-лошия случай при търсене, добавяне и триене на елемент.
- Балансиране е нужно при добавянето или триене на елемент, когато се наруши свойството за разлика във височините.

![AVL tree operations GIF](https://upload.wikimedia.org/wikipedia/commons/f/fd/AVL_Tree_Example.gif)

### Red-Black tree (Червено-черно дърво)

- Отново гарантира *O(logN)* сложност в най-лошия случай при търсене, добавяне и триене на елемент.
- Операциите добавяне и триене на елемент не изискват толкова често балансиране, поради по-малката строгост в поддържането на баланс спрямо AVL дърво.

Свойства:
- Коренът е винаги черен.
- Всяко листо е черно (NIL leaf).
- Децата на червен възел са винаги черни.
- Всеки директен път от корен на поддърво до всяко листо в поддървото (NIL leaf) минава през равен брой черни възли.

Следствие:
- Родителят на червен възел е винаги черен.
- Връх с един наследник е винаги червен.

![Example of Red-Black tree](https://upload.wikimedia.org/wikipedia/commons/thumb/4/41/Red-black_tree_example_with_NIL.svg/1920px-Red-black_tree_example_with_NIL.svg.png)

### Сравнение на структурите спрямо сложност по време

| операция | масив  | свързан списък | сортиран масив | двоично наредено дърво | балансирано дърво |
| -------- | ------ | -------------- | -------------- | ---------------------- | ----------------- |
| търсене  | *O(N)* | *O(N)*         | *O(logN)*      | *O(N)*                 | *O(logN)*         |
| добавяне | *O(N)* | *O(N)*         | *O(N)*         | *O(N)*                 | *O(logN)*         |
| триене   | *O(N)* | *O(N)*         | *O(N)*         | *O(N)*                 | *O(logN)*         |


### Имплементации в C++ и Python

Няма вградено балансирано двоично дърво за търсене в Python.
Структурите *set* и *dict* използват *Hash table*. Може да разгледате външата библиотека [Python Sorted Containers](https://grantjenks.com/docs/sortedcontainers/), която обаче не използва BST.

Аналогът на *set* и *dict* в C++ са *unordered_set* и *unordered_map*. Те също използват Хеш таблица. В C++ съществуват *ordered* варианти на горните колекции, които подреждат елементите/ ключовете по-големина. Така е нужно *inorder* обхождане, което е присъщо на балансираните дървета.

Примерна имплементация [AVL Tree in Python](https://github.com/TheAlgorithms/Python/blob/master/data_structures/binary_tree/avl_tree.py) и [Red-Black Tree in Python](https://github.com/TheAlgorithms/Python/blob/master/data_structures/binary_tree/red_black_tree.py).



## Hashtable (Хештаблица)

Основната идея на хештаблицата е да се възползва от бързия достъп до последователна памет както при списъка. За да е възможно това обаче, трябва да се използва метод за транслиране на обектите до цели положителни числа.

### Пример

Ако имаме низ *"abd"*, то той може лесно да бъде хеширан до цяло положително число. На всеки символ съпоставяме по едно число *("a" -> 1, "b" -> 2, "d" -> 4)* и събираме получените числа. Тогава нашият низ ще се хешира до стойността *7*.

Но ако низът ни е *"bad"*, то той ще има същата хеш стойност, което води до колизия, за които ще говорим по-нататък. 

Свеждането на конкретен обект до цяло число е работа на хеш функциите. 

### Хеш функции
Основните характеристиките на хеш функциите са:

- Да бъдат бързи за изчисление.
- Да създават минимален брой колизии. Справянето с колизиите увеличава средното време за изпълнение на заявка.
- Когато хешират един и същи обект, винаги да връщат една и съща стойност - да няма елемент на случайност или някакво състояние, което да повлияе на резултата от функцията (*stateless*).

### Справяне с колизии
Колизиите са неизбежна част от хеширането. Това са случаите, когато два **различни** обекта имат **една и съща** хеш стойност, след като биват прекарани през хеш функцията.
Съществуват няколко начина за справяне с колизии:

#### Separate chaining
- Това е най-популярният метод за справяне с колизии.
- Когато обект представен като цяло число, принадлежи на заета клетка - същото цяло число, двата обекта се нареждат в свързан списък. 
- Проверката дали елемент принадлежи в списъка се извършва линейно.
- Използва се свързан списък, защото бързо се добавя елемент в края и премахва елемент от средата.

#### Linear Probing
- Ако обект се хешира до дадено цяло число *x*, но то вече е заето, то тогава ще бъде попълнено първото число по-голямо от *x*, което е свободно. 
- Ако например обект се хешира до числото 5 и то е заето, то тогава се започва търсене в 6, 7 и т.н.
- Не толкова предпочитан метод, поради наличието на *clustering*.

#### Double Hashing
- Използва 2 хеширащи функции, през които да прекарва даден обект.
- При заета клетка, отговаряща на стойността от първата хеш функция, се търси свободна клетка спрямо втората хеш функция.
- Не се наблюдава *clustering*, както при *Linear probing* метода.

### Имплементации в Python

Основните стурктури в Python, които са имплементирани чрез хештаблица, са *set* и *dictionary*.
В C++ това са *unordered_set* и *unordered_map*.

#### Python set/ C++ unordered_set

Представлява множество, в което всеки елемент е хеширан. За амортизирано константно време - *О(1\*)*, може да извършва операциите:
1) Да провери дали съществува даден елемент в множество.
2) Да добави елемент в множеството.
3) Да премахне елемент в множеството.
4) Да вземе броя на елементите в множеството.

#### Python dictionary/ C++ unordered_map

Aналогична на *set*-a, но се състои от ключове, които сочат към стойности.
- Ключовете биват хеширани - отговарят на горепосочените характеристики на *set*-a.
- Не предоставя възможност за константа проверка дали дадена стойност съществува - единствено ключ.


## Задачи за упражнение

- [Volleyball Friends](https://www.hackerrank.com/contests/sda-hw-8/challenges/volleyball-friends)
- [Contains Duplicate II](https://leetcode.com/problems/contains-duplicate-ii)
- [Count Number of Bad Pairs](https://leetcode.com/problems/count-number-of-bad-pairs)

- [Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/)
- [K-diff Pairs in an Array](https://leetcode.com/problems/k-diff-pairs-in-an-array)
- [Group Anagrams](https://leetcode.com/problems/group-anagrams)
- [Repeated DNA Sequences](https://leetcode.com/problems/repeated-dna-sequences)
- [Longest Consecutive Sequence](https://leetcode.com/problems/longest-consecutive-sequence)
- [Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k)
- [0-1 Subarray](https://www.hackerrank.com/contests/sda-homework-9/challenges/0-1-1)
