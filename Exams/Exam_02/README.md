# Контролно 2  
## Структури от Данни и Алгоритми  


### Задача 1 (50т)

На първия ред от стандартния вход ще прочетете две числа:  
**N** – брой кутии с плодове и **H** – максимално време в часове.  

На следващия ред ще прочетете **N** на брой числа – броят плодове във всяка кутия.  

На всеки час избирате кутия и в рамките на този един час ядете само от тази кутия. За това време можете да изядете до **X** плода от кутията (ако в кутията има по-малко от **X** плода – изяждате всички, в противен случай – изяждате точно **X**).  

Разполагате с общо **H** часа, в рамките на които трябва да изядете всички плодове от всички кутии.  

Намерете **минималната възможна стойност за X**, такава че всички плодове да бъдат изядени в рамките на тези **H** часа.

| Вход                 | Изход |
| -------------------- | ----- |
| 4 8<br>3 6 7 11      | 4     |
| 5 5<br>30 11 23 4 20 | 30    |

---

### Задача 2 (25т)

Да се имплементира функцията `positiveStalinSort`, която приема указател към глава на свързан списък и изтрива всеки елемент, който е отрицателен или е по-малък от предходния неизтрит елемент.  

Функцията трябва да върне като резултат указател към главата на получения списък.  
Функцията **не трябва да позволява утечки на памет**!

#### C++
```cpp
struct Node {
    int data = 0;
    Node* next = nullptr;
};

Node* positiveStalinSort(Node* list);
````

#### Python

```python
class Node:
    def __init__(self, data=0, next_node=None):
        self.data = data
        self.next = next_node

def positiveStalinSort(lst: Optional[Node]) -> Optional[Node]:
    pass
```

| Входен списък             | Резултатен списък |
| ------------------------- | ----------------- |
| (1)→(-2)→(3)→(-4)→(2)→(5) | (1)→(3)→(5)       |
| (-1)→(2)→(-4)→(3)→(4)→(6) | (2)→(3)→(4)→(6)   |

---

### Задача 3 (50т)

Да се имплементира функцията `partition`, която приема указател към глава на свързан списък и пренарежда елементите му така, че в началото на списъка да са елементите **по-малки от x**, а след тях – елементите **по-големи или равни на x**.

Редът на елементите е без значение, стига горепосоченото правило да е спазено.

Функцията трябва да върне като резултат указател към главата на новополучения списък.
Функцията трябва да бъде със сложност по памет **O(1)**.

#### C++

```cpp
Node* partition(Node* list, int x);
```

#### Python

```python
def partition(lst: Optional[Node], x: int) -> Optional[Node]:
    pass
```

| Входни данни                      | Възможен резултатен списък   |
| --------------------------------- | ---------------------------- |
| (2)→(7)→(3)→(4)→(9)→(1)→(8), x=6  | (2)→(3)→(4)→(1)→(7)→(9)→(8)  |
| (-3)→(8)→(9)→(2)→(7)→(5)→(8), x=7 | (-3)→(2)→(5)→(8)→(9)→(7)→(8) |
