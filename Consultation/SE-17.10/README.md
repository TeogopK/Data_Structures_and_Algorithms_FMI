# Консултация по СДА #01
## Задачи 1 и 2
### Задача 1:
Имаме сграда с N на брой стаи. 

От всяка стая можем да влезем в точно определена друга стая (като посоката е от значение - тоест, ако от стая 0 мога да вляза в стая 1, това не означава автоматично, че обратното е възможно). Няма две стаи, които да водят към една и съща стая. 

Стаите трябва да бъдат изчистени, като за целта можем да изберем в кои от стаите да се “появят” чистачи. Те могат да се движат между стаите, но само по зададените по-горе правила. 

Да се изведе колко най-малко чистачи трябва да използваме, за да изчистим всички стаи и също така - колко време ще им отнеме.

Вход:
```c++
4 // Брой стаи
0 // От стая 0 се влиза в стая 0 
3 // От стая 1 се влиза в стая 3
1 // От стая 2 се влиза в стая 1
2 // От стая 3 се влиза в стая 2
```

Изход:
`2 3` - 2ма чистачи и ще им отнеме 3 часа

### Задача 2:
Имате дадена матрица 5x5, тя представя лабиринт, като с 0 означаваме, че през съответната позиция от матрицата може да се премине, докато с 1 означаваме, че тази позиция е ограда и не можем да преминем през нея. 

Да се напише функция, която по даден лабиринт, връща дали може да се стигне от една точка до друга.


## Задачи 3 и 4
### [Задача 3 - Subsets](https://leetcode.com/problems/subsets/description/)

### [Задача 4 - Two City Scheduling](https://leetcode.com/problems/two-city-scheduling/description/)

## Задача 5
Даден е масив от цели числа в диапазона [-100, 100]. Пренаредете масива така, че числата с еднакви абсолютни стойности да бъдат поставени едно до друго (редът е без значение).

**Пример:**

Вход: `-1 5 3 4 1 -3 -4 -5 1`

Изход (примерен възможен): `-1 1 1 -3 3 -4 4 -5 5`

## Задача 6
Даден е масив arr от цели числа.

Знаем, че елементите на четните позиции образуват сортирана възходящо подпоследователност, и елементите на нечетните позиции образуват сортирана низходящо подпоследователност. 

Създайте програма, която сортира колекцията за **ЛИНЕЙНО** време. Да изпринтира _сортираната колекция и индексите на съответните елементи_ в оригиналния масив.

Вход: `2 3 7 1 11 -15 14 -25 17 -33`

Изход: 
```
-33 9
-25 7
-15 5
1 3
2 0
3 1
7 2
11 4
14 6
17 8
```

## Code snippets

### Пример 1: Сложност Theta(n*log(n))
```c++
#include <vector>
using namespace std;

void example1(vector<int>& arr)
{
	size_t n = arr.size();
	for (size_t i = 1; i <= n; i += 2)
	{
		for (size_t j = 1; j <= n; j *= 2)
		{
			// Theta(1)
		}
	}
}
```
**Обяснение**: Вътрешният цикъл е със сложност log(n), а външният със сложност n. Също така не зависят един от друг и затова просто умножаваме сложностите.

### Пример 2: Сложност Theta(n)
```c++
void example2(vector<int>& arr)
{
	size_t n = arr.size();
	for (auto& el : arr)
	{
		for (size_t i = 1; i <= n; i++)
		{
			if ((el + i) % 2 == 0)
			{
				break;
			}
		}
	}
}
```
**Обяснение**: Преминаваме през всеки един от елементите на колекцията (тя има n елемента). За всеки елемент вътрешният цикъл ще се изпълни ли 1 или 2 пъти в зависимост от четността им (тоест константен брой). Така получаваме линейна сложност.

### Пример 3: Сложност Theta(n^3)
```c++
void example3(vector<int>& arr)
{
	size_t n = arr.size();
	for (size_t i = 1; i <= n; i++)
	{
		for (size_t j = i; j <= n; j++)
		{
			for (size_t k = 1; k <= n; k++)
			{
				// Theta(1)
			}
		}
	}
}
```
**Обяснение**: Най-вътрешният цикъл е изцяло независим и ще направи n завъртания всеки път. Останалите два (с водещи променливи i и j) са зависими и трябва да се разгледат едновременно. Пресмятайки, получаваме, че общия брой на завъртанията на средния цикъл са съответно n, n-1, n-2... и т.н. до 1 в зависимост от i. Получаваме n * (n + n-1 + n-2... + 1) = n * (n * (n+1) / 2), което е кубична сложност.

### Пример 4: Сложност Theta(n)
```c++
void example4(vector<int>& arr)
{
	int s = 0;
	size_t n = arr.size();
	for (size_t i = 1; i <= n; i++)
	{
		for (size_t j = n + i - 5; j <= n; j++)
		{
			s += 2;
		}

		s++;
	}
}
```
**Обяснения**: Вътрешният цикъл зависи от външния. Можем да забележим обаче, че той ще се изпълни за i = 1, 2, 3, 4, 5 само и при това ще направи 5, 4, 3, 2, 1 завъртания съответно (константен брой). След което той дори няма да се изпълнява. Сложността идва само от външният цикъл - линейна.

### Пример 5: Сложност Theta(n)
```c++
void example5(vector<int>& arr)
{
	size_t n = arr.size();
	for (size_t i = 1; i <= n; i *= 2)
	{
		for (size_t j = 1; j <= i; j++)
		{
			// Theta(1)
		}
	}
}
```
**Обяснение**: Виждаме, че циклите са зависими. Вътрешният цикъл ще направи толкова завъртания, колкото е стойността на i в момента: 1, 2, 4, 8, ..., n. Тоест броя стъпки на двата цикъла заедно ще е сума на степените на двойката от степен 0 до степен log(n) (тъй като n = 2^log2(n)). Знаем, че това е 2^(log2(n)+1)-1 = 2*n-1, което е линейна сложност. 

### Пример 6: Сложност Theta(n)
```c++
unsigned example6(unsigned n)
{
	if (n <= 1)
	{
		return 1;
	}

	return example6(n / 2) + example6(n / 2);
}
```
**Обяснение**: Тук задачата се решава с разписване на дървото на рекурсията. Виждаме, че дървото е перфектно двоично (всички листа са на едно ниво и всяко не-листо има две деца). Височината му виждаме, че е log2(n) и тъй като всеки възел ще върши константна работа (функцията example6 има само константен брой стъпки - няма цикли в нея), следва че можем просто да преброим колко са възлите в дървото на рекурсията. Перфектно двоично дърво с височина log(n) има 2^log(n) = n върха. Тоест: линейна сложност 

## Credits:
- [Пламена Илиева](https://github.com/plamena-ilieva/)
- [Иван Макавеев](https://github.com/IvanMakaveev)
